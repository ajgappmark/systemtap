set test "memory1"
set ::result_string {Test passed\r\n}

if {![installtest_p]} {
    untested $test
    return
}

# Use testcase specific directory for testcase artifacts
set artifactsdir [setup_artifacts_dir]
set curdir [pwd]
cd $artifactsdir

set uname [exec /bin/uname -r]

proc build_and_install_module {} {
    global artifactsdir
    global curdir subdir

    exec cp $curdir/$subdir/memory1_module.c $artifactsdir/
    exec cp -p $curdir/$subdir/memory1_module.Makefile $artifactsdir/Makefile

    # Build the module
    if {[catch {exec make -C $artifactsdir clean} res]} {
	verbose -log "$res"
	return 0
    }
    catch {exec make -C $artifactsdir} res
    verbose -log "$res"
    if {![file exists $artifactsdir/memory1_module.ko]} {
	return 0
    }
    set res [as_root [list cp $artifactsdir/memory1_module.ko /lib/modules/$::uname/kernel/]]
    if { $res != 0 } {
	verbose -log "$res"
	return 0
    }

    # Install the module
    set res [as_root [list /sbin/insmod $artifactsdir/memory1_module.ko]]
    if {$res != 0} {
	verbose -log "$res"
	return 0
    }
    return 1
}

proc cleanup_module {} {
    global artifactsdir
    as_root [list /bin/rm -f /lib/modules/$::uname/kernel/memory1_module.ko]
    as_root [list /sbin/rmmod memory1_module]
}

proc memory1_load {} {
    # Trigger the test module
    if {[file exists /proc/stap_memory1_test]} {
	exec echo Memory1Test > /proc/stap_memory1_test
	return 0
    } else {
	return 1
    }
}

if {[build_and_install_module] == 0} {
    verbose -log "BUILD FAILED"
    fail "$test (could not build/install module)"
    cd $curdir
    return
} else {
    pass "$test (built and installed module)"
}


# Note that we don't test other runtimes here since the script uses a
# kernel module
stap_run $curdir/$subdir/$test.stp memory1_load $result_string 
stap_run $curdir/$subdir/$test.stp memory1_load $result_string -DSTP_LEGACY_PRINT

cleanup_module

# Switch back from the testcase specific working directory
cd $curdir
